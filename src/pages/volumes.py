"""
Page for managing Docker volumes

Features:
- List all volumes with details (name, driver, mount point, scope, labels)
- Show which containers are using each volume
- Create new volumes
- Remove unused volumes
- Inspect volume details
- Prune unused volumes

"""

import streamlit as st
import docker
from datetime import datetime

# Initialize Docker client
try:
    client = docker.from_env()
except Exception as e:
    st.error(f"Failed to connect to Docker: {e}")
    st.stop()

st.title("üíæ Docker Volume Manager")


# Get all volumes
try:
    volumes = client.volumes.list()
except Exception as e:
    st.error(f"Failed to list volumes: {e}")
    st.stop()

# Get all containers to check volume usage
try:
    all_containers = client.containers.list(all=True)
except Exception as e:
    st.error(f"Failed to list containers: {e}")
    all_containers = []

# Build a map of volumes to containers
volume_usage = {}
for container in all_containers:
    mounts = container.attrs.get('Mounts', [])
    for mount in mounts:
        if mount.get('Type') == 'volume':
            volume_name = mount.get('Name')
            if volume_name:
                if volume_name not in volume_usage:
                    volume_usage[volume_name] = []
                volume_usage[volume_name].append({
                    'name': container.name,
                    'id': container.short_id,
                    'status': container.status,
                    'destination': mount.get('Destination', 'N/A')
                })



# Information section
with st.expander("‚ÑπÔ∏è About Docker Volumes"):
    st.markdown("""
    ### Docker Volumes
    
    Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.
    
    **Key Features:**
    - Volumes are stored in a part of the host filesystem managed by Docker
    - Multiple containers can use the same volume simultaneously
    - Volumes persist even when containers are removed
    - Easier to back up or migrate than bind mounts
    - Can be managed using Docker CLI or API
    
    **Volume States:**
    - üü¢ **In Use**: Volume is currently mounted to one or more containers
    - ‚ö™ **Unused**: Volume exists but is not mounted to any container
    
    **Best Practices:**
    - Use named volumes for important data
    - Regularly prune unused volumes to free up disk space
    - Use labels to organize and identify volumes
    - Back up important volumes regularly
    """)


# Create new volume section
st.header("‚ûï Create New Volume")
with st.expander("Create a new volume", expanded=False):
    st.markdown("""
    **Quick Guide:**
    - **Volume Name**: Give your volume a memorable name (e.g., `my-data`, `db-storage`). If left empty, Docker will generate a random name.
    - **Driver**: Determines where and how the volume data is stored. Use `local` for standard Docker storage.
    - **Labels**: Metadata tags to organize volumes (e.g., `environment=production`, `app=database`).
    """)
    
    with st.form("create_volume_form"):
        st.markdown("##### Basic Settings")
        new_volume_name = st.text_input(
            "Volume Name (optional)", 
            placeholder="my-app-data",
            help="A unique name for your volume. Must be lowercase, can contain letters, numbers, hyphens, and underscores. Leave empty for auto-generated name."
        )
        
        col1, col2 = st.columns(2)
        with col1:
            driver = st.selectbox(
                "Driver", 
                ["local", "custom"], 
                index=0,
                help="'local' stores data on the Docker host filesystem (recommended for most use cases). Choose 'custom' for third-party storage drivers like NFS, AWS EFS, etc."
            )
        with col2:
            if driver == "custom":
                custom_driver = st.text_input(
                    "Custom Driver Name",
                    placeholder="nfs, cifs, azure-file",
                    help="Name of the volume driver plugin (e.g., 'local-persist', 'rexray/ebs', 'vieux/sshfs')"
                )
        
        # Driver options
        with st.expander("Driver Options (optional)"):
            st.markdown("""
            **Driver-specific configuration settings:**
            - For `local` driver: `type` (e.g., `nfs`, `tmpfs`), `o` (mount options), `device` (mount source)
            - Example: `type=tmpfs, device=tmpfs, o=size=100m` for a temporary in-memory volume
            - Example: `type=nfs, o=addr=192.168.1.1,rw, device=:/path/to/dir` for NFS mount
            """)
            num_options = st.number_input("Number of options", min_value=0, max_value=10, value=0)
            driver_opts = {}
            for i in range(num_options):
                col_key, col_val = st.columns(2)
                with col_key:
                    key = st.text_input(f"Key {i+1}", key=f"opt_key_{i}", placeholder="e.g., type, device, o")
                with col_val:
                    val = st.text_input(f"Value {i+1}", key=f"opt_val_{i}", placeholder="e.g., nfs, tmpfs, size=100m")
                if key:
                    driver_opts[key] = val
        
        # Labels
        with st.expander("Labels (optional)"):
            st.markdown("""
            **Metadata for organizing and filtering volumes:**
            - Used to categorize and identify volumes
            - Common examples: `environment`, `project`, `team`, `backup`, `retention`
            - Format: `key=value` pairs (e.g., `app=mysql`, `env=production`, `team=backend`)
            - Labels don't affect volume behavior, only help with organization
            """)
            num_labels = st.number_input("Number of labels", min_value=0, max_value=10, value=0)
            labels = {}
            for i in range(num_labels):
                col_key, col_val = st.columns(2)
                with col_key:
                    key = st.text_input(f"Label Key {i+1}", key=f"label_key_{i}", placeholder="e.g., environment, app")
                with col_val:
                    val = st.text_input(f"Label Value {i+1}", key=f"label_val_{i}", placeholder="e.g., production, database")
                if key:
                    labels[key] = val
        
        submitted = st.form_submit_button("Create Volume", type="primary", use_container_width=True)
        
        if submitted:
            try:
                final_driver = custom_driver if driver == "custom" else driver
                volume_args = {
                    'driver': final_driver
                }
                if new_volume_name:
                    volume_args['name'] = new_volume_name
                if driver_opts:
                    volume_args['driver_opts'] = driver_opts
                if labels:
                    volume_args['labels'] = labels
                
                new_volume = client.volumes.create(**volume_args)
                st.success(f"‚úÖ Volume '{new_volume.name}' created successfully!")
                st.rerun()
            except Exception as e:
                st.error(f"Failed to create volume: {e}")

# List all volumes
st.header(f"üìã All Volumes ({len(volumes)})")

if volumes:
    # Prune unused volumes button
    unused_volumes = [v for v in volumes if v.name not in volume_usage]

    # Sort volumes: first by status (used first, then unused), then by name
    sorted_volumes = sorted(volumes, key=lambda v: (v.name not in volume_usage, v.name))
    
    # Display each volume
    for volume in sorted_volumes:
        # Determine if volume is in use
        is_used = volume.name in volume_usage
        status_icon = "üü¢" if is_used else "‚ö™"
        status_text = "In Use" if is_used else "Unused"
        
        # Keep expander open if there's a pending confirmation for this volume
        confirm_key = f"confirm_remove_{volume.name}"
        is_confirming = st.session_state.get(confirm_key, False)
        
        with st.expander(f"{status_icon} [{status_text}] **{volume.name}**", expanded=is_confirming):
            
            st.write(f"**Name:** `{volume.name}`")
            st.write(f"**Driver:** {volume.attrs.get('Driver', 'N/A')}")
            st.write(f"**Scope:** {volume.attrs.get('Scope', 'N/A')}")
            st.write(f"**Mountpoint:** `{volume.attrs.get('Mountpoint', 'N/A')}`")
            
            # Created date
            created = volume.attrs.get('CreatedAt', 'N/A')
            if created != 'N/A':
                try:
                    created_dt = datetime.fromisoformat(created.replace('Z', '+00:00'))
                    st.write(f"**Created:** {created_dt.strftime('%Y-%m-%d %H:%M:%S')}")
                except:
                    st.write(f"**Created:** {created}")
            
            # Labels
            labels = volume.attrs.get('Labels')
            if labels:
                st.write("**Labels:**")
                for key, value in labels.items():
                    st.write(f"  - `{key}`: {value}")
            
            # Options
            options = volume.attrs.get('Options')
            if options:
                st.write("**Options:**")
                for key, value in options.items():
                    st.write(f"  - `{key}`: {value}")
            
            # Show which containers are using this volume
            if is_used:
                st.write("**Used by:**")
                for container_info in volume_usage[volume.name]:
                    status_color = "üü¢" if container_info['status'] == 'running' else "‚ö™"
                    
                    # Create columns for container info and detach button
                    cont_col1, cont_col2 = st.columns([4, 1])
                    with cont_col1:
                        st.write(f"  {status_color} {container_info['name']} ({container_info['id']}) - mounted at `{container_info['destination']}`")
                    with cont_col2:
                        detach_key = f"detach_{volume.name}_{container_info['id']}"
                        if st.button("üîå", key=detach_key, help="Detach volume from this container", use_container_width=True):
                            # Confirmation for detach
                            confirm_detach_key = f"confirm_detach_{volume.name}_{container_info['id']}"
                            if confirm_detach_key not in st.session_state:
                                st.session_state[confirm_detach_key] = False
                            
                            if not st.session_state[confirm_detach_key]:
                                st.session_state[confirm_detach_key] = True
                                st.rerun()
                            else:
                                try:
                                    # Get the container
                                    container = client.containers.get(container_info['id'])
                                    config = container.attrs['Config']
                                    host_config = container.attrs['HostConfig']
                                    
                                    # Get existing mounts and remove this volume
                                    existing_mounts = host_config.get('Mounts', []) or []
                                    new_mounts = [m for m in existing_mounts if not (m.get('Type') == 'volume' and m.get('Source') == volume.name)]
                                    
                                    original_name = container.name
                                    was_running = container.status == 'running'
                                    
                                    # Stop and remove the original container
                                    if was_running:
                                        container.stop(timeout=10)
                                    container.remove()
                                    
                                    # Create new container without the volume
                                    new_container = client.containers.create(
                                        image=config['Image'],
                                        name=original_name,
                                        command=config.get('Cmd'),
                                        environment=config.get('Env'),
                                        ports=host_config.get('PortBindings'),
                                        mounts=new_mounts if new_mounts else None,
                                        network_mode=host_config.get('NetworkMode'),
                                        restart_policy=host_config.get('RestartPolicy'),
                                        detach=True
                                    )
                                    
                                    # Start if it was running before
                                    if was_running:
                                        new_container.start()
                                    
                                    st.success(f"‚úÖ Volume '{volume.name}' detached from container '{original_name}'")
                                    st.session_state[confirm_detach_key] = False
                                    st.rerun()
                                    
                                except Exception as e:
                                    st.error(f"Failed to detach volume: {e}")
                                    st.session_state[confirm_detach_key] = False
                        
                        # Show confirmation warning
                        if st.session_state.get(f"confirm_detach_{volume.name}_{container_info['id']}", False):
                            st.warning("‚ö†Ô∏è Click again to confirm detach")

            
            # Only allow removing if not in use
            if not is_used:
                if st.button("üóëÔ∏è Remove", key=f"remove_{volume.name}", type="secondary"):
                    # Confirmation dialog
                    confirm_key = f"confirm_remove_{volume.name}"
                    if confirm_key not in st.session_state:
                        st.session_state[confirm_key] = False
                    
                    if not st.session_state[confirm_key]:
                        st.session_state[confirm_key] = True
                        st.rerun()
                    else:
                        try:
                            volume.remove()
                            st.success(f"Removed volume '{volume.name}'")
                            st.session_state[confirm_key] = False
                            st.rerun()
                        except Exception as e:
                            st.error(f"Error: {e}")
                            st.session_state[confirm_key] = False
                
                # Show confirmation warning if in confirmation state
                if st.session_state.get(f"confirm_remove_{volume.name}", False):
                    st.warning("‚ö†Ô∏è Click Remove again to confirm")
            else:
                st.info("Cannot remove - volume is in use")

            # Show full details toggle button
            details_key = f"show_details_{volume.name}"
            if details_key not in st.session_state:
                st.session_state[details_key] = False
            
            button_text = "üìã Hide Details" if st.session_state[details_key] else "üìã Show Full Details"
            if st.button(button_text, key=f"details_{volume.name}"):
                st.session_state[details_key] = not st.session_state[details_key]
                st.rerun()
            
            if st.session_state[details_key]:
                st.json(volume.attrs)
            
            # Mount volume to container section
            st.markdown("---")
            st.markdown("**üîó Attach to Container**")
            
            # Initialize session state for mount form
            mount_form_key = f"show_mount_form_{volume.name}"
            if mount_form_key not in st.session_state:
                st.session_state[mount_form_key] = False
            
            if st.button("‚ûï Attach Volume to Container", key=f"show_mount_{volume.name}", use_container_width=True):
                st.session_state[mount_form_key] = not st.session_state[mount_form_key]
                st.rerun()
            
            if st.session_state[mount_form_key]:
                st.info("‚ö†Ô∏è Note: Docker doesn't support attaching volumes to running containers. This will recreate the container with the volume mounted.")
                
                with st.form(key=f"mount_form_{volume.name}"):
                    # Get containers that are not already using this volume
                    available_containers = [c for c in all_containers if volume.name not in [m.get('Name') for m in c.attrs.get('Mounts', []) if m.get('Type') == 'volume']]
                    
                    if not available_containers:
                        st.warning("No containers available. All containers are already using this volume or no containers exist.")
                        st.form_submit_button("Close", on_click=lambda: st.session_state.update({mount_form_key: False}))
                    else:
                        container_options = {f"{c.name} ({c.short_id}) - {c.status}": c for c in available_containers}
                        selected_container = st.selectbox(
                            "Select Container",
                            list(container_options.keys()),
                            help="Choose the container to attach this volume to"
                        )
                        
                        mount_path = st.text_input(
                            "Mount Path in Container",
                            placeholder="/data",
                            help="The path inside the container where the volume will be mounted (e.g., /data, /var/lib/mysql)"
                        )
                        
                        read_only = st.checkbox(
                            "Mount as read-only",
                            value=False,
                            help="If checked, the container can only read from the volume, not write to it"
                        )
                        
                        col_submit, col_cancel = st.columns(2)
                        with col_submit:
                            submitted = st.form_submit_button("üîÑ Recreate Container with Volume", type="primary", use_container_width=True)
                        with col_cancel:
                            cancelled = st.form_submit_button("Cancel", use_container_width=True)
                        
                        if cancelled:
                            st.session_state[mount_form_key] = False
                            st.rerun()
                        
                        if submitted and mount_path:
                            container = container_options[selected_container]
                            
                            try:
                                # Get container configuration
                                config = container.attrs['Config']
                                host_config = container.attrs['HostConfig']
                                
                                # Prepare new mounts
                                existing_mounts = host_config.get('Mounts', []) or []
                                new_mount = {
                                    'Type': 'volume',
                                    'Source': volume.name,
                                    'Target': mount_path,
                                    'ReadOnly': read_only
                                }
                                existing_mounts.append(new_mount)
                                
                                # Store original container name
                                original_name = container.name
                                was_running = container.status == 'running'
                                
                                # Stop and remove the original container
                                if was_running:
                                    container.stop(timeout=10)
                                container.remove()
                                
                                # Create new container with the volume
                                new_container = client.containers.create(
                                    image=config['Image'],
                                    name=original_name,
                                    command=config.get('Cmd'),
                                    environment=config.get('Env'),
                                    ports=host_config.get('PortBindings'),
                                    mounts=existing_mounts,
                                    network_mode=host_config.get('NetworkMode'),
                                    restart_policy=host_config.get('RestartPolicy'),
                                    detach=True
                                )
                                
                                # Start if it was running before
                                if was_running:
                                    new_container.start()
                                
                                st.success(f"‚úÖ Container '{original_name}' recreated with volume '{volume.name}' mounted at '{mount_path}'")
                                st.session_state[mount_form_key] = False
                                st.rerun()
                                
                            except Exception as e:
                                st.error(f"Failed to recreate container: {e}")
                                st.error("The container may have been removed. Please check the container list.")
            
                

else:
    st.info("No volumes found")

